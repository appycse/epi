#+TITLE: Elements of Programming Interviews: Solutions
#+AUTHOR: Jonathan Jin
#+STARTUP: logdone showall
#+TODO: TODO(t) | WRITTEN(w) PSEUDOCODE(c) DONE(d) LOOKED-UP(l)

* Table of Contents                                                  :TOC:TOC_3:
- [[#data-structures-and-algorithms][Data Structures and Algorithms]]
  - [[#primitive-types][Primitive Types]]
    - [[#computing-the-parity-of-a-word][Computing the parity of a word]]
    - [[#compute-xy][Compute x^{y}]]
  - [[#arrays][Arrays]]
    - [[#the-dutch-national-flag-problem][The Dutch national flag problem]]
    - [[#sample-offline-data][Sample offline data]]
    - [[#sample-online-data][Sample online data]]
    - [[#compute-the-spiral-ordering-of-a-2d-array][Compute the spiral ordering of a 2D array]]
    - [[#buy-and-sell-a-stock-once][Buy and sell a stock once]]
  - [[#strings][Strings]]
    - [[#interconvert-strings-and-integers][Interconvert strings and integers]]
    - [[#base-conversion][Base conversion]]
    - [[#replace-and-remove][Replace and remove]]
  - [[#linked-lists][Linked Lists]]
    - [[#merge-two-sorted-lists][Merge two sorted lists]]
    - [[#reverse-a-singly-linked-list][Reverse a singly linked list]]
    - [[#test-for-cyclicity][Test for cyclicity]]
    - [[#test-for-overlapping-lists----lists-are-cycle-free][Test for overlapping lists -- lists are cycle-free]]
    - [[#remove-the-kth-last-element-from-a-list][Remove the k^{th} last element from a list]]
    - [[#implement-even-odd-merge][Implement even-odd merge]]
    - [[#test-whether-a-singly-linked-list-is-palindromic][Test whether a singly linked list is palindromic]]
  - [[#stacks-and-queues][Stacks and Queues]]
    - [[#implement-a-stack-with-max-api][Implement a stack with =max= API]]
    - [[#test-a-string-of-parentheses-braces-and-brackets-for-well-formedness][Test a string of parentheses, braces, and brackets for well-formedness]]
    - [[#compute-binary-tree-nodes-in-order-of-increasing-depth][Compute binary tree nodes in order of increasing depth]]
  - [[#binary-trees][Binary Trees]]
    - [[#test-if-a-binary-tree-is-height-balanced][Test if a binary tree is height-balanced]]
    - [[#compute-the-lca-when-nodes-have-parent-pointers][Compute the LCA when nodes have parent pointers]]
    - [[#test-if-a-binary-tree-is-symmetric][Test if a binary tree is symmetric]]
    - [[#looked-up-reconstruct-a-binary-tree-from-traversal-data][LOOKED-UP Reconstruct a binary tree from traversal data]]
    - [[#implement-an-inorder-traversal-with-o1-space][Implement an inorder traversal with O(1) space]]
    - [[#reconstruct-a-binary-tree-from-a-preorder-traversal-with-markers][Reconstruct a binary tree from a preorder traversal with markers]]
    - [[#compute-the-right-sibling-tree][Compute the right sibling tree]]
  - [[#heaps][Heaps]]
    - [[#merge-sorted-files][Merge sorted files]]
    - [[#compute-the-k-closest-stars][Compute the k closest stars]]
  - [[#searching][Searching]]
    - [[#search-a-sorted-array-for-first-occurrence-of-k][Search a sorted array for first occurrence of =k=]]
    - [[#compute-the-integer-square-root][Compute the integer square root]]
    - [[#find-the-k-th-largest-element][Find the k-th largest element]]
  - [[#hash-tables][Hash Tables]]
    - [[#partition-into-anagrams][Partition into anagrams]]
    - [[#test-for-palindromic-permutations][Test for palindromic permutations]]
    - [[#is-an-anonymous-letter-constructible][Is an anonymous letter constructible?]]
    - [[#implement-an-isbn-cache][Implement an ISBN cache]]
  - [[#sorting][Sorting]]
    - [[#compute-the-intersection-of-two-sorted-arrays][Compute the intersection of two sorted arrays]]
    - [[#implement-mergesort-in-place][Implement mergesort in-place]]
    - [[#count-the-frequencies-of-characters-in-a-sentence][Count the frequencies of characters in a sentence]]
    - [[#render-a-calendar][Render a calendar]]
    - [[#compute-the-union-of-intervals][Compute the union of intervals]]
    - [[#implement-a-fast-sorting-algorithm-for-lists][Implement a fast sorting algorithm for lists]]
    - [[#partitioning-and-sorting-an-array-with-many-repeated-entries][Partitioning and sorting an array with many repeated entries]]
  - [[#binary-search-trees][Binary Search Trees]]
    - [[#test-if-a-binary-tree-satisfies-the-bst-property][Test if a binary tree satisfies the BST property]]
    - [[#find-the-first-key-larger-than-a-given-value-in-a-bst][Find the first key larger than a given value in a BST]]
    - [[#find-the-k-largest-elements-in-a-bst][Find the k largest elements in a BST]]
  - [[#recursion][Recursion]]
    - [[#tower-of-hanoi][Tower of Hanoi]]
    - [[#generate-all-nonattacking-placements-of-n-queens][Generate all nonattacking placements of n-Queens]]
  - [[#dynamic-programming][Dynamic Programming]]
    - [[#written-count-the-number-of-score-combinations][WRITTEN Count the number of score combinations]]
    - [[#compute-the-levenshtein-distance][Compute the Levenshtein distance]]
    - [[#count-the-number-of-ways-to-traverse-a-2d-array][Count the number of ways to traverse a 2D array]]
    - [[#compute-the-binomial-coefficient-without-overflow][Compute the binomial coefficient without overflow]]
    - [[#search-for-a-sequence-in-a-2d-array][Search for a sequence in a 2D array]]
  - [[#greedy-algorithms-and-invariants][Greedy Algorithms and Invariants]]
    - [[#the-3-sum-problem][The 3-sum problem]]
    - [[#the-gasup-problem][The gasup problem]]
  - [[#graphs][Graphs]]
    - [[#search-a-maze][Search a maze]]
    - [[#written-transform-one-string-to-another][WRITTEN Transform one string to another]]
  - [[#parallel-computing][Parallel Computing]]
- [[#domain-specific-problems][Domain Specific Problems]]
  - [[#design-problems][Design Problems]]
  - [[#language-questions][Language Questions]]
  - [[#object-oriented-design][Object-Oriented Design]]
  - [[#common-tools][Common Tools]]
- [[#honors-class][Honors Class]]
- [[#unlicense][(Un)license]]

* Data Structures and Algorithms

** Primitive Types

*** DONE Computing the parity of a word                                     :C0:
    CLOSED: [2017-06-21 Wed 00:44]
    
    The parity of a binary word is 1 if the number of 1s in the word is odd;
    otherwise, it is 0. For example, the parity of 1011 is 1, and the parity of
    10001000 is 0. Parity checks are used to detect single bit errors in data
    storage and communication. It is fairly straightforward to write code that
    computes the parity of a single 64-bit word
    
**** Solution

     We assume that the word is provided as a 64-bit unsigned integer.

     A naive implementation would be to iterate through every bit of the word,
     XOR-ing a counter for every 1-bit.

     #+BEGIN_SRC python :results silent :session
       def parity(word):
           p = 0
           for shift in range(0,64):
               p ^= (word>>shift)&1
           return p
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([parity(int(w,2))==p for w,p in [
           ("1011", 1),
           ("0000", 0),
       ]])
     #+END_SRC

     #+RESULTS:
     : True

     This implementation is O(n), where n is the length of the input word.

     We can, however, optimize this function further by precomputing the
     parities of words and storing the parities in a lookup table. For
     illustration's purpose, we'll define a lookup table that stores the
     parities of all words of length 2:

     #+BEGIN_SRC python :results none :session
       PARITIES_2 = {
           int(w,2): p for w,p in [
               ("00", 0),
               ("01", 1),
               ("10", 1),
               ("11", 0),
           ]
       }
     #+END_SRC

     Resulting in the following implementation:

     #+BEGIN_SRC python :results none :session
       def memoized_parity(word):
           p = 0
           memo_word_length = 2
           for s in range(0,64/memo_word_length):
               mask = 2^memo_word_length - 1
               shift = s * memo_word_length
               p ^= PARITIES_2[(word >> shift) & mask]
           return p
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([memoized_parity(int(w,2))==p for w,p in [
           ("1011", 1),
           ("0000", 0),
       ]])
     #+END_SRC

     #+RESULTS:
     : True

     This revised implementation is O(n/w) = O(n), where w is the word length of
     the lookup key.

*** TODO Compute x^{y}                                                         :C1:

    Compute x^{y} without using arithmetic operators, i.e. using only assignment,
    bitwise operators, and equality checks.

** Arrays
   
*** TODO The Dutch national flag problem                                    :C0:

    Write a program that takes an array A and an index i into A, and rearranges
    the elements such that all elements less than A[i] (the "pivot") appear
    first, followed by eleents equal to the pivot followed by elements greater
    than the pivot.

    /Hint/: Think about the partition step in quicksort.

**** Solution

*** DONE Sample offline data                                                :C1:
    CLOSED: [2017-06-27 Tue 00:00]

    Implement an algorithm that takes as input an array of distinct elements and
    a size, and returns a subset of the given size of the array elements. All
    subsets should be equally likely.

**** Solution

     We can use reservoir sampling to achieve a linear-time implementation.

     #+BEGIN_SRC python :results output :session
       def sample(N, l):
           from random import randint
           reservoir = [N[i] for i in range(0, l)]
           for i in range(l, len(N)):
               _i = randint(0, i)
               if _i < l:
                   reservoir[_i] = N[i]
           return reservoir
     #+END_SRC

*** DONE Sample online data
    CLOSED: [2017-06-27 Tue 00:00]

    Design a program that takes as input a size k, and reads packets,
    continuously maintaining a uniform random subset of size k of the read
    packets.

**** Solution

     Analogous to solution outlined in "Sample offline data."

*** TODO Compute the spiral ordering of a 2D array                          :C1:

*** DONE Buy and sell a stock once                                          :C0:
    CLOSED: [2017-06-22 Thu 12:28]

    This problem is concerned with the problem of optimally buying and selling a
    stock once. As an example, consider the following sequence of stock prices:
    =<310, 315, 275, 295, 260, 270, 290, 230, 255, 250>=. The maximum profit
    that can be made with one buy and one sell is 30 -- buy at 260 and sell
    at 290. Note that 260 is not the lowest price, nor 290 the highest price.

    Write a program that takes an array denoting the daily stock price, and
    returns the maximum profit that could be made by buying and then selling one
    share of that stock.
    
**** Solution

     Note that this problem is a simplification of the knapsack problem. A naive
     solution would reduce this problem to its inspiration, giving us a O(n^{2})
     solution.  However, we note that the problem doesn't ask for exactly
     *which* stocks to buy and sell for maximum profit -- only the profit
     amount. This simplification means that we do not need the comprehensive
     bookkeeping that a DP-based solution to the knapsack problem provides us.

     We first note that a lower buying price always results in a higher profit
     with the same selling price.

     We can then implement a O(n) solution that compares the "current profit" --
     defined as difference between the current sell-price under consideration
     and the as-yet-seen lowest buy price, with a rolling maximum of that
     value. Every time we see a value less than the as-yet-seen lowest buy
     price, we update accordingly. Once we reach the end of the list, we return
     the rolling max value.

     #+BEGIN_SRC python :results silent :session
       def max_profit(*args):
           min_so_far = args[0]
           profit = 0
           for p in args:
               profit = max(profit, p - min_so_far)
               if p < min_so_far:
                   min_so_far = p
           return profit
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       max_profit(310,315,275,295,260,270,290,230,255,250) == 30
     #+END_SRC

     #+RESULTS:
     : True

** Strings

*** DONE Interconvert strings and integers                                  :C0:
    CLOSED: [2017-06-26 Mon 22:08]

    Implement string/integer inter-conversion functions.

**** Solution
     
     #+BEGIN_SRC python :results silent :session
        def stoi(s):
            i = 0
            for c in s:
                i = 10 * i + ord(c) - ord("0")
            return i
     #+END_SRC
     
     #+BEGIN_SRC python :results value :session
        all([
            stoi("123") == 123,
            stoi("0") == 0,
            stoi("98765432198") == 98765432198,
        ])      
     #+END_SRC
     
     #+RESULTS:
      : True

     #+BEGIN_SRC python :results silent :session
       def itos(i):
           import math
           s = ""
           while True:
               s += chr(ord("0") + i % 10)
               i = int(math.floor(i / 10))
               if i == 0:
                   break
           return s[::-1]
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           itos(123) == "123",
           itos(0) == "0",
           itos(98765432198) == "98765432198",
       ])      
     #+END_SRC

     #+RESULTS:
     : True

*** TODO Base conversion                                                    :C1:

    In the decimal number system, the position of a digit is used to signify the
    power of 10 that digit is to be multiplied with. For example, "314" denotes
    the number 3 * 100 + 1 * 10 + 4 * 1. The base b number system generalizes
    the decimal number system: the string "a_{k-1}a_{k-2}...a_{1}a_{1}", where 0 \leq a_i \leq
    b, denotes in base-b the integer a_0 \times b^{0} + a_1 \times b^{1} + a_2 \times
    b^{2} + ... + a_{k-1} \times b^{k-1}.

    Write a program that performs base conversion. The input is a string, an
    integer b_1, and another integer b_2. The string represents an integer in base
    b_1. The output should be the string representing the integer in base
    b_2. Assume 2 \leq b_1, b_2 \leq 16. Use "A" to represent 10, "B" for 11, ..., and
    "F" for 15. (For example, if the string is "615", b_1 is 7 and b_2 is 13, then
    the result should be "1A7", since 6 \times 7^{2} + 1 \times 7 + 5 = 1 \times 13^{2} + 10 \times 13 + 7).

*** TODO Replace and remove                                                 :C1:

    Consider the following two rules that are to be applied to an array of
    characters.

    - Replace each "a" by two "d"s.
    - Delete each entry containing a "b".


    For example, applying these rules to the array =<a,c,d,b,b,c,a>= results in
    the array =<d,d,c,d,c,d,d>=.

    Write a program which takes as input an array of characters, and removes
    each "b" and replaces each "a" by two "d"s. Specifically, along with the
    array, you are provided an integer-valued size. Size denotes the number of
    entries of the array that the operation is to be applied to. You do not
    have to worry about preserving subsequent entries. For example, if the array
    is =<a,b,a,c,_>= and the size is 4, then you can return =<d,d,d,d,c>=. You
    can assume there is enough space in the array to hold the final result.
    
** Linked Lists

*** DONE Merge two sorted lists                                             :C0:
    CLOSED: [2017-06-21 Wed 12:53]

    Write a program that takes two lists, assumed to be sorted, and returns
    their merge. The only field your program can change in a node is its =next=
    field.

    /Hint/: Two sorted arrays can be merged using two indices. For lists, take
    care when one iterator reaches the end.
    
**** Solution

     We describe a solution that completes the task in linear time and constant
     space.

     Call input lists =A= and =B=.

     We decide on the head of the return list with respect to comparison. We
     save a reference =H= to this head for final return; in the meantime, we
     create an additional "work-in-progress" reference =l= that we will use to
     iteratively wire up the return value.

     While neither =A= nor =B= have reached their ends, we compare the head
     values of each; whichever is less than or equal to the other, becomes the
     new target for =l.next=. We then increment both the assignee and =l= to
     their next links.

     Once one of =A= or =B= have reached their end, we treat the other as the
     "remainder" list. Since the two input lists are given to be sorted, we have
     the invariant that every element in the remainder is greater than or equal
     to the current =l=. As such, we assign =l.next = remainder=.

     For this solution's purpose, we define a lightweight linked-list API as
     follows:

     #+BEGIN_SRC python :results silent :session
       class LL():
           def __init__(self, v):
               self.v = v
               self.next = None
           def append(self, l):
               self.next = l
               return self
           def __eq__(self,l):
               me = self
               while me is not None and l is not None:
                   if me.v != l.v:
                       return False
                   me = me.next
                   l = l.next
               return me is None and l is None 
     #+END_SRC

     Our solution is as follows:

     #+BEGIN_SRC python :results silent :session
       def merge(A,B):
           if A is None:
               return B
           if B is None:
               return A
           if A.v < B.v:
               head = A
               A = A.next
           else:
               head = B
               B = B.next
           l = head # wip tracker
           cursors = { "A": A, "B": B }
           while cursors["A"] is not None and cursors["B"] is not None:
               k_next = "A" if cursors["A"].v < cursors["B"].v else "B"
               l.next = cursors[k_next]
               l = l.next
               cursors[k_next] = cursors[k_next].next
           l.next = cursors["A"] if cursors["A"] is not None else cursors["B"]
           return head
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           # base cases
           merge(None,None) == None,
           merge(None, LL(1).append(LL(2))) == LL(1).append(LL(2)),
           merge(LL(1).append(LL(3)), None) == LL(1).append(LL(3)),

           # "normal" case
           merge(
               LL(1).append(LL(3).append(LL(5))),
               LL(2).append(LL(4).append(LL(6))),
           ) == LL(1).append(LL(2).append(LL(3).append(LL(4).append(LL(5).append(LL(6)))))),

           # remainder case
           merge(
               LL(1).append(LL(5)),
               LL(2).append(LL(6).append(LL(10))),
           ) == LL(1).append(LL(2).append(LL(5).append(LL(6).append(LL(10))))),
       ])
     #+END_SRC

     #+RESULTS:
     : True

*** DONE Reverse a singly linked list                                       :C1:
    CLOSED: [2017-06-27 Tue 13:07]

**** Solution

     #+BEGIN_SRC python :results output :session
       class LL():
           def __init__(self, v):
               self.v = v
               self.next = None
           def append(self, l):
               self.next = l
               return self
           def __eq__(self,l):
               me = self
               while me is not None and l is not None:
                   if me.v != l.v:
                       return False
                   me = me.next
                   l = l.next
               return me is None and l is None 
     #+END_SRC

     #+RESULTS:

     #+BEGIN_SRC python :results output :session
       def ll_rev(L):
           tail = None
           cursor = L
           while cursor is not None:
               nxt = cursor.next
               cursor.next = tail
               tail = cursor
               cursor = nxt
           return tail
     #+END_SRC

     #+BEGIN_SRC python :results output :session
     ll_rev(LL(4).append(LL(5).append(LL(6)))) == LL(6).append(LL(5).append(LL(4)))
     #+END_SRC

*** TODO Test for cyclicity                                                 :C1:

*** TODO Test for overlapping lists -- lists are cycle-free                 :C2:

    Write a program that takes two cycle-free singly linked lists, and
    determines if there exists a node that is common to both lists.

*** TODO Remove the k^{th} last element from a list                         :C2:

*** TODO Implement even-odd merge                                           :C3:

*** TODO Test whether a singly linked list is palindromic                   :C4:

** Stacks and Queues
   
*** DONE Implement a stack with =max= API                                   :C0:
    CLOSED: [2017-06-21 Wed 01:06]

    Design a stack that includes a max operation, in addition to push and
    pop. The max method should return the maximum value stored in the stack.
    
**** Solution

     We can use an augmentation of a "vanilla" stack for this purpose. Each
     element of this augmented stack -- call it a "max stack" -- will maintain a
     record of the maximum value at or below its current level. This will allow
     us to preserve the following invariant for given max-stack =S=:

     #+BEGIN_VERBATIM
     S.head.max = max(S)
     #+END_VERBATIM

     We can implement the max-stack as follows:

     #+BEGIN_SRC python :results silent :session
       class MaxStack():
           def __init__(self, *args):
               self.record = []
               for v in args:
                   self.push(v)
           def push(self, v):
               if not self.record:
                   self.record.append((v,v))
               else:
                   self.record.append((v,max(v,self.record[-1][1])))
               return self
           def pop(self):
               if not self.record:
                   return None
               out = self.record[-1][0]
               self.record = self.record[0:-1]
               return out
           # drop silently pops 
           def drop(self):
               self.pop()
               return self
           def max(self):
               if not self.record:
                   return None
               return self.record[-1][1]
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           MaxStack(1,4,3,2,5).max() == 5,
           MaxStack(1,4,3,2,5).drop().max() == 4,
           MaxStack(2,3,4,1).drop().drop().max() == 3,
       ])
     #+END_SRC

     #+RESULTS:
     : True

     This implementation is:

     - O(1) for push;
     - O(1) for pop;
     - O(1) for max lookup.


     Space complexity is O(2n) = O(n), where n is the stack size.

*** DONE Test a string of parentheses, braces, and brackets for well-formedness
    CLOSED: [2017-06-25 Sun 22:46]

**** Solution

     #+BEGIN_SRC python :results silent :session
       def is_well_formed(S):
           PAIRS = {
               "{": "}",
               "(": ")",
               "[": "]",
           }
           opens = []
           for c in S:
               if c in PAIRS:
                   opens.append(c)
               elif opens and c == PAIRS[opens[-1]]:
                   opens = opens[:-1]
               else:
                   return False
           return not opens
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           is_well_formed(""),
           is_well_formed("()"),
           is_well_formed("[]"),
           is_well_formed("{}"),
           is_well_formed("{[()]}"),
           not is_well_formed("{[([)]}"),
           not is_well_formed("}"),
       ])
     #+END_SRC

     #+RESULTS:
     : True

*** DONE Compute binary tree nodes in order of increasing depth             :C1:
    CLOSED: [2017-06-27 Tue 13:29]

**** Solution

     We use a queue as the basis of our solution. We start with the input tree T
     in the queue. For each node N in the queue, we enqueue its children, and
     then yield N. We continue until the queue is empty for a final time
     complexity of O(n) and likewise for space.

     #+BEGIN_SRC python :results silent :session
       def serialize_inc_depth(T):
           q = [T]
           while q and q[0] is not None:
               curr = q[0]
               q.extend([c for c in [curr.l, curr.r] if c])
               yield q.popleft()
     #+END_SRC

** Binary Trees

*** DONE Test if a binary tree is height-balanced                           :C0:
    CLOSED: [2017-06-25 Sun 21:56]

    A binary tree is said to be balanced if for each node in the tree, the
    difference in the height of its left and right subtrees is at most one. A
    perfect binary tree is balanced, as is a complete binary tree. A balanced
    binary tree does not have to be perfect or complete.

    Write a program that takes as input the root of a binary tree and checks
    whether the tree is balanced.
    
**** Solution

     We can use a post-order traversal as the backbone for our implementation.

     For each subtree, we determine its height. When traversing parent nodes, if
     the difference in the height of its two subtrees is greater than 1, we
     return false immediately. Otherwise, we return one greater than the greater
     of the two children heights.

     #+BEGIN_SRC python :results output :session
       def is_height_balanced(T):
           def height(n):
               if not n:
                   return 0
               hl, hr = height(n.left), height(n.right)
               if abs(hl - hr) > 1:
                   raise Exception
               return max(hl, hr) + 1
           try:
               height(T)
           except Exception:
               return False
           return True
     #+END_SRC

     This implementation is O(n), where n is the number of nodes in the tree. It
     is O(1) in space. 
     
*** DONE Compute the LCA when nodes have parent pointers                    :C1:
    CLOSED: [2017-06-25 Sun 18:37]

**** Solution

     We note that the solution is trivial if the nodes are at the same depth:
     iterate in tandem until you reach the common ancestor node. This operation
     is O(log n).

     Otherwise, if the nodes are at different depths, we can iterate the deeper
     node until both cursors are at the same depth, at which point the problem
     reduces to the same-depth case.

     Both of these cases require us to determine the depths of the two
     nodes. This can be done by tracing the respective parent pointers to the
     root and storing the traversal length.

     We note that both depth-determination and final traversal are O(log n); the
     combined solution is O(log n) w.r.t. time and O(1) w.r.t. space.

*** DONE Test if a binary tree is symmetric                                 :C2:
    CLOSED: [2017-06-29 Thu 15:50]

    A binary tree is symmetric if you can draw a vertical line through the root
    and then the left subtree is the mirror image of the right subtree.

    Write a program that checks whether a binary tree is symmetric.

    /Hint/: The definition of symmetry is recursive.

**** Solution

     We note that trees  T_{1} and T_{2} are symmetric if their root values are equal
     and T_{1}'s left child equals T_{2}'s right child and vice-versa.

     We recursively check the input tree. The input root level is a special case
     where we simply check children equality. We then begin recursive
     "mirroring" comparison on the two child trees. "Mirroring" comparison
     consists of first checking that the left-right and right-left child value
     equalities are satisfied and then performing recursive mirroring comparison
     on the left-right and right-left pairs.

     #+BEGIN_SRC python :results silent :session
       class Tree():
           def __init__(self, v, l=none, r=none):
               self.v = v
               self.l = l
               self.r = r
     #+END_SRC

     #+BEGIN_SRC python :results output :session
       def is_sym(T):
           def is_mirror(T1, T2):
               return ((T1 is None and T2 is None)
                       or (T1.v == T2.v
                           and is_mirror(T1.l, T2.r)
                           and is_mirror(T1.r, T2.l)))
           return T is None or is_mirror(T.l, T.r)
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           is_sym(None),
           is_sym(Tree(v=1, l=Tree(v=2), r=Tree(v=2))),
           is_sym(Tree(
               v=1,
               l=Tree(v=2, l=Tree(v=3, l=Tree(v=10)), r=Tree(v=4)),
               r=Tree(v=2, l=Tree(v=4), r=Tree(v=3, r=Tree(v=10))),
           )),
           not is_sym(Tree(v=1, l=Tree(v=2), r=Tree(v=3))),
       ])
     #+END_SRC

     #+RESULTS:
     : True

     
*** LOOKED-UP Reconstruct a binary tree from traversal data                 :C2:
    CLOSED: [2017-07-01 Sat 18:00]

    Given an inorder traversal sequence and a preorder traversal sequence of a
    binary tree write a program to reconstruct the tree. Assume each node has a
    unique key.

    /Hint/: Focus on the root.

**** Solution

     #+BEGIN_SRC python :results silent :session
       def teq(t1, t2):
           return (t1 is None and t2 is None) or (
               t1.v == t2.v
               and teq(t1.l, t2.l)
               and teq(t1.r, t2.r))

       class Tree():
           def __init__(self, v, l=None, r=None):
               self.v = v
               self.l = l
               self.r = r
           def __eq__(self, T):
               return teq(self, T)
     #+END_SRC

     #+BEGIN_SRC python :results silent :session
       def recon(s_in, s_pre):
           t = Tree(v=s_pre[0])
           s_in_l = s_in[:s_in.index(t.v)]
           s_pre_l = s_pre[1:len(s_in_l)+1]
           s_in_r = s_in[s_in.index(t.v)+1:]
           s_pre_r = s_pre[len(s_in_l)+1:]
           if len(s_in_l) != len(s_pre_l) or len(s_in_r) != len(s_pre_r):
               raise Exception()
           if len(s_in_l) != 0:
               t.l = recon(s_in_l, s_pre_l)
           if len(s_in_r) != 0:
               t.r = recon(s_in_r, s_pre_r)
           return t
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       t = recon("DBFEGACH", "ABDEFGCH")

       t == Tree(
           v="A",
           l=Tree(
               v="B",
               l=Tree(v="D"),
               r = Tree(v="E", l = Tree(v="F"), r = Tree(v="G")),
           ),
           r = Tree(v = "C", r = Tree(v="H")),
       )
     #+END_SRC

     #+RESULTS:
     : True

*** TODO Implement an inorder traversal with O(1) space                     :C3:

    The direct implementation of an inorder traversal using recursion has O(h)
    space complexity, where h is the height of the tree. Recursion can be
    removed with an explicit stack, but the space complexity remains O(n).

    Write a nonrecursive program for computing the inorder traversal sequence
    for a binary tree. Assume nodes have parent fields.

    /Hint/: How can you tell whether a node is a left child or right child of
    its parent?

*** TODO Reconstruct a binary tree from a preorder traversal with markers   :C4:

    Design an algorithm for reconstructing a binary tree from a preorder
    traversal visit sequence that uses =null= to mark empty children.

    /Hint/: It's difficult to solve this problem by examining the preorder
    traversal visit sequence from left-to-right.

*** TODO Compute the right sibling tree                                     :C4:

    Assume each binary tree node has an extra field, call it level-next, that
    holds a binary tree node (this field is distinct from the fields for the
    left and right children). The level-next field will be used to compute a map
    from nodes to their right siblings. The input is assumed to be perfect
    binary tree.

    Write a program that takes a perfect binary tree, and sets each node's
    level-next field to the node on its right, if one exists.

    /Hint/: Think of an appropriate traversal order.

** Heaps

*** TODO Merge sorted files                                                 :C0:

*** TODO Compute the k closest stars                                        :C1:
** Searching

*** TODO Search a sorted array for first occurrence of =k=                  :C0:

    Binary search commonly asks for the index of /any/ element of a sorted array
    that is equal to a specified element. The following problem has a slight
    twist on this.

    Write a method that takes a sorted array and a key and returns the index of
    the /first/ occurrence of the key in the array.

*** TODO Compute the integer square root                                    :C1:

*** TODO Find the k-th largest element                                      :C1:

** Hash Tables

*** DONE Partition into anagrams                                            :C0:
    CLOSED: [2017-06-26 Mon 22:19]

    Write a program that takes as input a set of words and returns groups of
    anagrams for those words. Each group must contain at least two words.

**** Solution

     We can implement solution that avoids the need to compare all pairs of
     strings by hashing each string to its sorted version. Strings whose sorted
     forms are equal are anagrams. This implementation uses n calls to sort for
     O(n m log m), where n is the number of strings and m is the length of the
     max string.

     #+BEGIN_SRC python :results silent :session
       def get_anagram_clusters(S):
           cs = {}
           for s in S:
               k = ''.join(sorted(s))
               if k not in cs:
                   cs[k] = set()
               cs[k].add(s)
           return [v for _,v in cs.iteritems()]

     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           s in get_anagram_clusters([
               "debitcard",
               "elvis",
               "silent",
               "badcredit",
               "lives",
               "freedom",
               "listen",
               "levis",
               "money",
           ]) for s in [
               set(["debitcard", "badcredit"]),
               set(["elvis", "lives", "levis"]),
               set(["silent", "listen"]),
           ]
       ])
     #+END_SRC

     #+RESULTS:
     : True

*** DONE Test for palindromic permutations
    CLOSED: [2017-06-25 Sun 00:14]

    Write a program to test whether the letters forming a string can be permuted
    to form a palindrome. For instance, "edified" can be permuted to form
    "deified".

**** Solution

     We assume that there is no requirement that the resulting palindrome be a
     word in the English language.

     We note that, in the case of even-length strings, we require the count of
     each letter to be evenly divisible by two. We additionally note that, in
     the case of odd-length strings, there is one and only one letter with count
     of one.

     This implementation is O(n) in time and space.

     #+BEGIN_SRC python :results silent :session
       def can_palindrome(s):
           lcs = {}
           for c in s:
               if c not in lcs:
                   lcs[c] = 0
               lcs[c] += 1
           if len(s) % 2 == 0:
               return all(v % 2 == 0 for k,v in lcs.iteritems())
           else:
               is_pivot_found = False
               for k,v in lcs.iteritems():
                   if v == 1:
                       if is_pivot_found:
                           return False
                       else:
                           is_pivot_found = True
                           continue
                   elif v % 2 != 0:
                       return False
               return True
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           can_palindrome("racecar"),
           can_palindrome("rraacce"),
           not can_palindrome("foobar"),
       ])
     #+END_SRC

     #+RESULTS:
     : True

*** DONE Is an anonymous letter constructible?                              :C1:
    CLOSED: [2017-06-23 Fri 12:41]

    Write a program which takes text for an anonymous letter and text for a
    magazine and determines if it is possible to write the anonymous letter
    using the magazine. The letter can be written using the magazine if for each
    character in the letter, the number of times it appears in the anonymous
    letter is no more than the number of times it appears in the magazine.

**** Solution

     We implement a solution that reduces the letter and the magazine into
     dictionaries. We then check that the magazine dictionary contains all of
     the letter dictionary's keys and, for each of those keys, that it maps to a
     count greater than or equal to that contained in the letter dictionary.

     This solution is in time O(n) with respect to the cumulative length of the
     letter and magazine. Space is, similarly, O(n).

     For the sake of simplicity, we assume that inputs do not contain
     spaces. Accounting for spaces is trivial and would simply involve splitting
     each input on whitespace characters and iterating across sub-lists.

     #+BEGIN_SRC python :results output :session
       def is_possible(l, m):
           def to_dict(s):
               out = {}
               for c in s:
                   if c not in out:
                       out[c] = 0
                   out[c] += 1
               return out

           dl = to_dict(l)
           dm = to_dict(m)

           for k,v in dl.iteritems():
               if k not in dm or dm[k] < v:
                   return False

           return True
     #+END_SRC

*** TODO Implement an ISBN cache                                            :C1:

** Sorting

*** DONE Compute the intersection of two sorted arrays                      :C0:
    CLOSED: [2017-06-23 Fri 15:24]

    Write a program which takes as input two sorted arrays, and returns a new
    array containing elements that are present in both of the input arrays. The
    input arrays may have duplicate entries, but the returned array should be
    free of duplicates. For example, if the input is =<2,3,3,5,5,6,7,7,8,12>=
    and =<5,5,6,8,8,9,10,10>=, your output should be =<5,6,8>=.

**** Solution

     #+BEGIN_SRC python :results output :session
       def intersection(A,B):
           if not A or not B:
               return []
           out = []
           lower,upper = A, B
           while lower and upper:
               lower = lower if lower[0] < upper[0] else upper
               upper = upper if lower[0] < upper[0] else lower
               while lower and lower[0] != upper[0]:
                   lower = lower[1:]
               if not lower or not upper:
                   break
               item = lower[0]
               out.append(item)
               while lower and lower[0] == item:
                   lower = lower[1:]
               while upper and upper[0] == item:
                   upper = upper[1:]
           return out
     #+END_SRC

     #+RESULTS:

     #+BEGIN_SRC python :results value :session
       all([
           intersection([],[]) == [],
           intersection([],[1,2,3]) == [],
           intersection([1,2,3],[]) == [],
           intersection(
               [1,2,3,4,5],
               [4,4,5,6,7],
           ) == [4,5,6,7],
           intersection(
               [1,2,3],
               [4,5,6],
           ) == [],
       ])  
     #+END_SRC

     #+RESULTS:
     : True

     This implementation is linear on its inputs.

*** TODO Implement mergesort in-place                                       :C1:

    Write a program which takes as input two sorted arrays of integers, and
    updates the first to the combined entries of the two arrays in sorted
    order. Assume the first array has enough empty entries at its end to hold
    the result.

    /Hint/: Avoid repeatedly moving entries.

*** DONE Count the frequencies of characters in a sentence                  :C2:
    CLOSED: [2017-06-28 Wed 15:32]

    Given a string, print in alphabetical order each character that appears in
    the string, and the number of times that it appears. For example, if the
    string is "bcdacebe", output =(a,1), (b,2), (c,2), (d,1), (e,2)=.

    /Hint/: Exploit the fact that the keys are drawn from a small set.

**** Solution

     We assume that the input string consists solely of lowercase alphabetic
     characters. However, the solution is generalizeable.

     We point out that the character domain is finite -- specifically, of
     size 26. As such, we use an array of size 26, with index representing
     character, with "0" corresponding to "a" etc., to record the number of
     times the corresponding letter appears in the input string. It is then
     trivial to output the array values in alphabetical order.

     Both the record-keeping operation and the output operation are linear. The
     overall solution is linear in time and constant in space.

     #+BEGIN_SRC python :results silent :session
       def freqs(S):
           counts = [0] * 26
           for c in S:
               counts[ord(c) - ord("a")] += 1
           for i in range(len(counts)):
               if counts[i] > 0:
                   yield (chr(ord("a")+i), counts[i])
     #+END_SRC

     #+BEGIN_SRC python :results value :session
     list(freqs("bcdacebe")) == [("a",1),("b",2),("c",2),("d",1), ("e",2)]
     #+END_SRC

     #+RESULTS:
     : True

*** DONE Render a calendar                                                  :C2:
    CLOSED: [2017-06-28 Wed 18:20]

    Write a program that takes a set of events, and determines the maximum
    number of events that can take place concurrently.

**** Solution

     We assume that the domain is unbounded -- that is, that any event can occur
     at any given time t.

     We assume that an event E is represented as a tuple (t_{s}, t_{e}), where t_{s} is
     the start time and t_{e} the end time.

     Instead of considering discrete time values, we consider unit
     intervals. For instance, the event (t, t+2) falls into two interval
     "buckets" -- the first representing the interval [t, t+1], and the second
     the interval [t+1, t+2].

     We maintain a counter dictionary, keyed on the start times of these
     intervals, that keeps track of how many events overlap with the key
     interval. For each event E, we split E into its constituent unit intervals
     and populate the counter accordingly. We choose dictionary for the
     following reasons:

     - We assume no bound on the domain of time T, so we choose a data structure
       that doesn't require an explicit initial size for convenience;
     - We make no assumptions about the proximity of the respective events'
       intervals; we can very easily have events (0, 10) and (10000,
       10010). Using an alternative storage construct, such as an array, would
       require us to allocate upwards of 10000 buckets to store information for
       these events, only for all but twenty of those buckets to be meaningless,
       i.e. with value zero. A dictionary, on the other hand, allows us to only
       allocate 20 buckets, for considerably greater space efficiency.


     The resulting solution is O(nl) in time and space, where n is the number of
     events and l is the max length of the event intervals.


     #+BEGIN_SRC python :results silent :session
       def atomize_interval(start, end):
           for s in range(start, end):
               yield (s, s+1)
     #+END_SRC

     #+BEGIN_SRC python :results value :session
     list(atomize_interval(0,5)) == [(0,1), (1,2), (2,3), (3,4), (4,5)]
     #+END_SRC

     #+RESULTS:
     : True

     #+BEGIN_SRC python :results silent :session
       def max_sim(*E):
           time_to_sim = {}
           for e in E:
               for i in atomize_interval(*e):
                   if i[0] not in time_to_sim:
                       time_to_sim[i[0]] = 0
                   time_to_sim[i[0]] += 1
           return time_to_sim[max(time_to_sim, key=(lambda k: time_to_sim[k]))]
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           max_sim((0,10)) == 1,
           max_sim((0,10),(2,11),(3,12)) == 3,

           # non-contiguous events
           max_sim((0,10), (2,11), (100, 110), (101,111), (102,112), (103,113)) == 4,
       ])
     #+END_SRC

     #+RESULTS:
     : True

*** TODO Compute the union of intervals                                     :C3:

*** TODO Implement a fast sorting algorithm for lists                       :C3:

*** TODO Partitioning and sorting an array with many repeated entries       :C4:
** Binary Search Trees

*** DONE Test if a binary tree satisfies the BST property                   :C0:
    CLOSED: [2017-06-23 Fri 12:20]

    Write a program that takes as input a binary tree and checks if the tree
    satisfies the BST property.

**** Solution

     Iterate through each subtree, keeping track of a local maximum and
     minimum. In addition to asserting that the two leaves relate to the node as
     necessary, similarly assert that the two leaves fall within the maximum and
     minimum. When recursing into leaves, update either the maximum or the
     minimum with the current node value depending on which leave is being
     recursed into.

*** TODO Find the first key larger than a given value in a BST              :C1:
    
*** DONE Find the k largest elements in a BST                               :C1:
    CLOSED: [2017-06-27 Tue 15:25]

**** Solution

     We can use reverse in-order traversal, yielding values until the count has
     been satisfied, for an implementation that is O(n) in time and O(log n) in
     space, where n is the number of entries in the BST.

     #+BEGIN_SRC python :results silent :session
       class Tree():
           def __init__(self, v, l=None, r=None):
               self.v = v
               self.l = l
               self.r = r
     #+END_SRC

     #+BEGIN_SRC python :results silent :session
       def get_k_largest(T, k):
           def _get_k_largest(T,k):
               if not T:
                   return [], k
               vs, k_rem = _get_k_largest(T.r,k)
               if k_rem == 0:
                   return vs, 0
               vs.append(T.v)
               k_rem -= 1
               if k_rem == 0:
                   return vs, 0
               lhs, k_rem = _get_k_largest(T.l, k_rem)
               vs.extend(lhs)
               if k_rem == 0:
                   return vs, 0
               return vs, k_rem 
           vs, _ = _get_k_largest(T,k)
           return vs
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           get_k_largest(Tree(
               v = "A",
               l = Tree(v = "B", l = Tree(v = "D"), r = Tree(v = "E")),
               r = Tree(
                   v = "C",
                   l = Tree(v = "F"),
                   r = Tree(
                       v = "G",
                       l = Tree(v = "H", r = Tree(v = "J")),
                       r = Tree(v = "I"),
                   ),
               ),
           ), 9) == ["I", "G", "J", "H", "C", "F", "A", "E", "B"],
       ])
     #+END_SRC

     #+RESULTS:
     : True

** Recursion

*** TODO Tower of Hanoi                                                     :C0:

*** TODO Generate all nonattacking placements of n-Queens                   :C1:

** Dynamic Programming

*** WRITTEN Count the number of score combinations                          :C0:
    CLOSED: [2017-06-23 Fri 15:03]

    In an American football game, a play can lead to 2 points (safety), 3 points
    (field goal), or 7 points (touchdown, assuming the extra point). Many
    different combinations of 2, 3, and 7 point plays can make up a final
    score. For example, four combinations of plays yield a score of 12:

    - 6 safeties;
    - 3 safeties, 2 field goals;
    - 1 safety, 1 field goal, and 1 touchdown;
    - 4 field goals.


    Write a program that takes a final score and scores for individual plays,
    and returns the number of combinations of plays that result in the final
    score.

**** Solution

     We can memoize the number of combinations that lead to certain scores,
     iterating through the memo to arrive at the desired final score and, as a
     result, the final combination count.

     Say we have possible play scores 2 and 3, and we'd like the number of
     possible plays that could lead to a score of 9. We can represent our memo
     as a two-dimensional array, where one axis is the score and the other
     represents the set of plays that can comprise the score, the first index
     representing, in this case, the set ={2}= and the second, the set ={2,3}=.

     We note that, for a given score =S= and a given set of plays =P = {P', p}=,
     number of combinations leading to score =S= =N(S, P)= equals (informally):

     =N(S-p, P') + N(S-2p, P') + ... + N(0, P')=

     We say that =N(x, y) = 0= for =x<0= and any =y=.

     |         | *0* | *1* | *2* | *3* | *4* | *5* | *6* | *7* | *8* | *9* |
     | ={2}=   |   1 |   0 |   1 |   0 |   1 |   0 |   1 |   0 |   1 |   0 |
     | ={2,3}= |   1 |   0 |   1 |   1 |   1 |   1 |   2 |   1 |   2 |   2 |

     A solution that uses this memoization strategy will be =O(S \times |P|)=, where
     =S= is the score and =P= is the set of play scores. Likewise for space.

*** TODO Compute the Levenshtein distance                                   :C1:

*** DONE Count the number of ways to traverse a 2D array
    CLOSED: [2017-06-23 Fri 19:18]

**** Solution

     Our memoization strategy is as follows. We use a matrix T of the same
     shape as the input matrix M to track the number of ways to traverse to
     that point in the input. Matrix T is populated according to function
     T(i,j), which we define as follows:

     - T(i,j) = T(i-1,j) + T(i, j-1)
     - T(i, j) = 0 \forall j \in \real, i < 0
     - T(i, j) = 0 \forall j < 0, i \in \real


     Our solution then becomes as follows:

     #+BEGIN_SRC python :results silent :session
       def num_traversals(M):
           t = [[0 for _ in M[0]] for _ in M]
           def T(t, i,j):
               if i == -1 or j == -1:
                   return 0
               if i == 0 and j == 0:
                   return 1
               return t[i-1][j] + t[i][j-1]
           for i in range(0, len(M)):
               for j in range(0, len(M[i])):
                   t[i][j] = T(t, i, j)
           return t[len(M)-1][len(M[0])-1]
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           num_traversals([[0,0,0,0,0] for _ in xrange(5)]) == 70,
       ])
     #+END_SRC

     This implementation is linear for both time and space with respect to the
     number of elements in the input matrix.

*** DONE Compute the binomial coefficient without overflow
    CLOSED: [2017-06-24 Sat 21:10]

**** Solution

     For illustration's purpose, we outline a C matrix, where C[n][k] = C(n+1,k+1)
     \forall n,k \in \real:

     | 1 | 2 | 3 | 4 |
     | 0 | 1 | 3 | 6 |
     | 0 | 0 | 1 | 4 |
     | 0 | 0 | 0 | 1 |

     We note that this gives us the following recursive definition of the
     binominal coefficient: C(n, k) = C(n-1, k-1) + C(n-1, k). A naive
     implementation would directly translate this recursive definition into a
     recursive implementation, resulting in re-computation of the same values
     for exponential time complexity w.r.t nk. Instead, we memoize intermediate
     results in a manner identical to the example matrix above:

     #+BEGIN_SRC python :results output :session
       def bico(n,k):
           def C(_C, n, k):
               if n == k:
                   return 1
               elif k == 0:
                   return n + 1
               elif k > n:
                   return 0
               else:
                   return _C[k-1][n-1] + _C[k][n-1]
           _C = [[0 for _ in xrange(n)] for _ in xrange(k)]
           for _k in range(0, k):
               for _n in range(0, n):
                   _C[_k][_n] = C(_C, _n, _k)
           return _C[k-1][n-1]
     #+END_SRC

     #+RESULTS:

     #+BEGIN_SRC python :results output :session
       all([
           bico(29, 3) == 3654,
           bico(3, 2) == 3,
       ])
     #+END_SRC

     This solution is O(nk) for both time and space.

*** DONE Search for a sequence in a 2D array
    CLOSED: [2017-06-24 Sat 22:48]

    Write a program that takes as arguments a 2D array and a 1D array, and
    checks whether the 1D array appears in the 2D array.

**** Solution

     We can use iteration through each element of the 2D array as the backbone
     of our solution's logic; during iteration, if we encounter an element
     that's equal to the first element of the sequence, we break into tracing
     logic. This tracing logic considers all of the element's "neighbors" to see
     if they equal the next value in the sequence. We "trace" the sequence in
     this way; if we reach the end of the sequence in this way, we return true
     and are done. If, however, tracing leads to only a partial match, we mark
     the latest element in the trace as "invalid" and propagate that mark
     backwards through the trace. This is to prevent re-tracing of paths that
     are already known to be "lost causes" -- an implementation that would lead
     to time complexity of O(nml), where n and m are the matrix's dimensions and
     l is the length of the sequence. The result, where we preemptively avoid
     tracing paths that have already been deemed to not match the argument
     sequence, is an implementation that is in time O(nm) (traversal of the
     input sequence is amortized).

     #+BEGIN_SRC python :results silent :session
       def contains_sequence(M, S):
           # eligibility matrix
           m_e = [[True for _ in xrange(len(M[0]))] for _ in xrange(len(M))]
           def neighbor_coords(i, j):
               if i < len(M)-1:
                   yield (i+1, j)
               if i > 0:
                   yield (i-1, j)
               if j < len(M[0])-1:
                   yield (i, j+1)
               if j > 0:
                   yield (i, j-1)
           def trace(i, j, seq):
               if not seq:
                   return True
               if not m_e[i][j]:
                   return False
               if M[i][j] != seq[0] or not any([
                       trace(nc[0], nc[1], seq[1:]) for nc in neighbor_coords(i, j)
               ]):
                   m_e[i][j] = False
                   return False
               else:
                   return True
           for i in range(0, len(M)):
               for j in range(0, len(M[0])):
                   if trace(i, j, S):
                       return True
           return False
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           contains_sequence(M, S) == r for M,S,r in [
               (
                   [[1,2,5],
                    [3,4,3],
                    [5,6,7]],
                   [3,4,7],
                   False,
               ),
               (
                   [[1,2,5],
                    [3,4,3],
                    [5,6,7]],
                   [3,4,6,7],
                   True,
               ),
               (
                   [[1,2,3],
                    [3,4,5],
                    [5,6,7]],
                   [1,3,4,6],
                   True,
               ),
               (
                   [[1,2,3],
                    [3,4,5],
                    [5,6,7]],
                   [1,2,3,4],
                   False,
               ),
           ]
       ])
     #+END_SRC

     #+RESULTS:
     : True

** Greedy Algorithms and Invariants

*** TODO The 3-sum problem                                                  :C0:

*** TODO The gasup problem                                                  :C1:

** Graphs

*** DONE Search a maze                                                      :C0:
    CLOSED: [2017-06-26 Mon 16:50]

    Given a 2D array of black and white entries representing a maze with
    designated entrance and exit points, find a path from the entrance to the
    exit, if one exists.

    /Hint/: Model the maze as a graph.

**** Solution

     We assume the input is a matrix of integers, where any non-zero integer
     represents a wall and, similarly, 0 represents a walkable segment.

     We treat the 2D array as a graph and implement DFS, with two
     optimizations.

     First, our recursion keeps a record of the path taken, such that, if our
     given recursion finds a cycle, it disqualifies itself as a possible path to
     the exit. This will prevent our implementation from failing to return if
     the maze contains a cycle, as in the following example input:

     #+BEGIN_VERBATIM
     -> 1 1 1 0
        1 0 1 0
        1 1 1 0
        0 0 0 0 ->
     #+END_VERBATIM

     Secondly -- and building off of the first optimization -- we maintain a
     "disqualification" memo matrix which tracks whether a given point (x,y) is
     an exit candidate, i.e. has not been proven to not lead to the exit. if all
     paths from a particular point (x,y) in the maze result in dead ends --
     defined as either "no more paths to take, and still not at the exit" or
     "entered a cycle" -- then that point (x,y) is also disqualified. This will
     prevent us from computing subpaths repeatedly, as a naive implementation
     would on the following input:

     #+BEGIN_VERBATIM
     -> 1 1 1 0
        1 0 1 0
        1 1 1 1
        0 0 0 0 ->
     #+END_VERBATIM

     First, we implement a function to return all "edges" of a given "vertex" in
     our matrix-graph:

     #+BEGIN_SRC python :results silent :session
       def get_edges(M, V):
           for f, e in [
               (lambda V: V[0] > 0, (V[0] - 1, V[1])),
               (lambda V: V[1] > 0, (V[0], V[1] - 1)),
               (lambda V: V[0] < len(M) - 1, (V[0] + 1, V[1])),
               (lambda V: V[1] < len(M[0]) - 1, (V[0], V[1] + 1))
           ]:
               if f(V) and M[e[0]][e[1]] != 0:
                   yield e
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           set(get_edges([
               [1, 1, 0],
               [1, 0, 0],
               [0, 0, 0],
           ], (0,0))) == set([(1,0), (0,1)]),

           set(get_edges([
               [1, 1, 0],
               [0, 0, 0],
               [0, 0, 0],
           ], (0,0))) == set([(0,1)]),
       ])
     #+END_SRC

     #+BEGIN_SRC python :results output :session
       def get_exit_path(M, xy_in, xy_out):
           is_qualified = [[True for _ in M[0]] for _ in M]
           def _get_exit_path(cursor, set_visited):
               if cursor == xy_out:
                   return [cursor]
               if cursor in set_visited or not is_qualified[cursor[0]][cursor[1]]:
                   is_qualified[cursor[0]][cursor[1]] = False
                   return []
               for e in get_edges(M, cursor):
                   rest = _get_exit_path(e, set_visited | {cursor})
                   if rest != []:
                       return [cursor] + rest
               return []
           return _get_exit_path(xy_in, set())
     #+END_SRC

     #+RESULTS:

     #+BEGIN_SRC python :results value :session
       all([
           get_exit_path([
               [1, 1, 0],
               [1, 0, 0],
               [1, 1, 1],
           ], (0,1), (2,2)) == [(0,1), (0,0), (1,0), (2,0), (2,1), (2,2)],
           get_exit_path([
               [0, 1, 0],
               [1, 0, 0],
               [1, 1, 1],
           ], (0,1), (2,2)) == [],
       ])
     #+END_SRC

     #+RESULTS:
     : True

*** WRITTEN Transform one string to another                                 :C1:
    CLOSED: [2017-06-29 Thu 15:13]

    Let s and t be strings and D a dictionary, i.e. a set of strings. Define s
    to produce t if there exists a sequence of strings from the dictionary P =
    <s_0, s_1, ..., s_{n-1}> such that the first string is s, the last string is t,
    and adjacent strings have the same length and differ in exactly one
    character. The sequence P is called a /production sequence/. For example, if
    the dictionary is ={bat, cot, dog, dag, dot, cat}=, then =<cat, cot, dot,
    dog>= is a production sequence.

    Given a dictionary D and two strings s and t, write a program to determine
    if s produces t. Assume that all characters are lowercase alphabets. If s
    does produce t, output the length of the shortest production sequence;
    otherwise, output -1.

    /Hint/: Treat strings as vertices in an undirected graph, with an edge
    between u and v if and only if the corresponding strings differ in one
    character.

**** Solution

     Create a graph according to the hint in time complexity O(n^{2}). Traverse the
     graph using BFS in time O(|V| + |E|) = O(n + n^{2}) = O(n^{2}).

     Note that we don't need to necessarily "create" a graph per se; edges can
     be "discovered" ad-hoc by finding words in the dictionary that are one
     character off from the current vertex.
       
** Parallel Computing
   
* Domain Specific Problems
  
** Design Problems
   
** Language Questions
   
** Object-Oriented Design
   
** Common Tools
   
* Honors Class
  
* (Un)license
  
  #+BEGIN_SRC text :eval never
    This is free and unencumbered software released into the public domain.

    Anyone is free to copy, modify, publish, use, compile, sell, or
    distribute this software, either in source code form or as a compiled
    binary, for any purpose, commercial or non-commercial, and by any
    means.

    In jurisdictions that recognize copyright laws, the author or authors
    of this software dedicate any and all copyright interest in the
    software to the public domain. We make this dedication for the benefit
    of the public at large and to the detriment of our heirs and
    successors. We intend this dedication to be an overt act of
    relinquishment in perpetuity of all present and future rights to this
    software under copyright law.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
    OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

    For more information, please refer to <http://unlicense.org>
  #+END_SRC
