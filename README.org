#+TITLE: Elements of Programming Interviews: Solutions
#+AUTHOR: Jonathan Jin
#+STARTUP: logdone showall

* Table of Contents                                                  :TOC:TOC_3:
- [[#data-structures-and-algorithms][Data Structures and Algorithms]]
  - [[#4-primitive-types][4 Primitive Types]]
    - [[#41-computing-the-parity-of-a-word][4.1 Computing the parity of a word]]
  - [[#5-arrays][5 Arrays]]
    - [[#51-the-dutch-national-flag-problem][5.1 The Dutch national flag problem]]
    - [[#56-buy-and-sell-a-stock-once][5.6 Buy and sell a stock once]]
  - [[#6-strings][6 Strings]]
    - [[#62-base-conversion][6.2 Base conversion]]
    - [[#64-replace-and-remove][6.4 Replace and remove]]
  - [[#7-linked-lists][7 Linked Lists]]
    - [[#71-merge-two-sorted-lists][7.1 Merge two sorted lists]]
  - [[#8-stacks-and-queues][8 Stacks and Queues]]
    - [[#81-implement-a-stack-with-max-api][8.1 Implement a stack with =max= API]]
  - [[#9-binary-trees][9 Binary Trees]]
    - [[#91-test-if-a-binary-tree-is-height-balanced][9.1 Test if a binary tree is height-balanced]]
  - [[#10-heaps][10 Heaps]]
  - [[#11-searching][11 Searching]]
  - [[#12-hash-tables][12 Hash Tables]]
  - [[#13-sorting][13 Sorting]]
  - [[#14-binary-search-trees][14 Binary Search Trees]]
  - [[#15-recursion][15 Recursion]]
  - [[#16-dynamic-programming][16 Dynamic Programming]]
  - [[#17-greedy-algorithms-and-invariants][17 Greedy Algorithms and Invariants]]
  - [[#18-graphs][18 Graphs]]
  - [[#19-parallel-computing][19 Parallel Computing]]
- [[#domain-specific-problems][Domain Specific Problems]]
  - [[#20-design-problems][20 Design Problems]]
  - [[#21-language-questions][21 Language Questions]]
  - [[#22-object-oriented-design][22 Object-Oriented Design]]
  - [[#23-common-tools][23 Common Tools]]
- [[#honors-class][Honors Class]]
- [[#unlicense][(Un)license]]

* Data Structures and Algorithms

** 4 Primitive Types

*** DONE 4.1 Computing the parity of a word
    CLOSED: [2017-06-21 Wed 00:44]
    
    The parity of a binary word is 1 if the number of 1s in the word is odd;
    otherwise, it is 0. For example, the parity of 1011 is 1, and the parity of
    10001000 is 0. Parity checks are used to detect single bit errors in data
    storage and communication. It is fairly straightforward to write code that
    computes the parity of a single 64-bit word
    
**** Solution

     We assume that the word is provided as a 64-bit unsigned integer.

     A naive implementation would be to iterate through every bit of the word,
     XOR-ing a counter for every 1-bit.

     #+BEGIN_SRC python :results silent :session
       def parity(word):
           p = 0
           for shift in range(0,64):
               p ^= (word>>shift)&1
           return p
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([parity(int(w,2))==p for w,p in [
           ("1011", 1),
           ("0000", 0),
       ]])
     #+END_SRC

     #+RESULTS:
     : True

     This implementation is O(n), where n is the length of the input word.

     We can, however, optimize this function further by precomputing the
     parities of words and storing the parities in a lookup table. For
     illustration's purpose, we'll define a lookup table that stores the
     parities of all words of length 2:

     #+BEGIN_SRC python :results none :session
       PARITIES_2 = {
           int(w,2): p for w,p in [
               ("00", 0),
               ("01", 1),
               ("10", 1),
               ("11", 0),
           ]
       }
     #+END_SRC

     Resulting in the following implementation:

     #+BEGIN_SRC python :results none :session
       def memoized_parity(word):
           p = 0
           memo_word_length = 2
           for s in range(0,64/memo_word_length):
               mask = 2^memo_word_length - 1
               shift = s * memo_word_length
               p ^= PARITIES_2[(word >> shift) & mask]
           return p
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([memoized_parity(int(w,2))==p for w,p in [
           ("1011", 1),
           ("0000", 0),
       ]])
     #+END_SRC

     #+RESULTS:
     : True

     This revised implementation is O(n/w) = O(n), where w is the word length of
     the lookup key.
     
** 5 Arrays
   
*** TODO 5.1 The Dutch national flag problem

    Write a program that takes an array A and an index i into A, and rearranges
    the elements such that all elements less than A[i] (the "pivot") appear
    first, followed by eleents equal to the pivot followed by elements greater
    than the pivot.

    /Hint/: Think about the partition step in quicksort.

**** Solution

*** TODO 5.6 Buy and sell a stock once

    This problem is concerned with the problem of optimally buying and selling a
    stock once. As an example, consider the following sequence of stock prices:
    =<310, 315, 275, 295, 260, 270, 290, 230, 255, 250>=. The maximum profit
    that can be made with one buy and one sell is 30 -- buy at 260 and sell
    at 290. Note that 260 is not the lowest price, nor 290 the highest price.

    Write a program that takes an array denoting the daily stock price, and
    returns the maximum profit that could be made by buying and then selling one
    share of that stock.
    
** 6 Strings
   
*** TODO 6.2 Base conversion

    In the decimal number system, the position of a digit is used to signify the
    power of 10 that digit is to be multiplied with. For example, "314" denotes
    the number 3 * 100 + 1 * 10 + 4 * 1. The base b number system generalizes
    the decimal number system: the string "a_{k-1}a_{k-2}...a_{1}a_{1}", where 0 \leq a_i \leq
    b, denotes in base-b the integer a_0 \times b^0 + a_1 \times b^1 + a_2 \times
    b^2 + ... + a_{k-1} \times b^{k-1}.

    Write a program that performs base conversion. The input is a string, an
    integer b_1, and antoher integer b_2. The string represents an integer in base
    b_1. The output should be the string representing the integer in base
    b_2. Assume 2 \leq b_1, b_2 \leq 16. Use "A" to represent 10, "B" for 11, ..., and
    "F" for 15. (For example, if the string is "615", b_1 is 7 and b_2 is 13, then
    the result should be "1A7", since 6 \times 7^2 + 1 \times 7 + 5 = 1 \times 13^2 + 10 \times 13 + 7).

*** TODO 6.4 Replace and remove

    Consider the following two rules that are to be applied to an array of characters.

    - Replace each "a" by two "d"s.
    - Delete each entry containing a "b".


    For example, applying these rules to the array =<a,c,d,b,b,c,a>= results in
    the array =<d,d,c,d,c,d,d>=.

    Write a program which takes as input an array of characters, and removes
    each "b" and replaces each "a" by two "d"s. Specifically, along with the
    array, you are provided an integer-valued size. Size denotes the number of
    entries of the array that the operation is to be applied to. You do not
    have to worry about preserving subsequent entries. For example, if the array
    is =<a,b,a,c,_>= and the size is 4, then you can return =<d,d,d,d,c>=. You
    can assume there is enough space in the array to hold the final result.
    
** 7 Linked Lists

*** DONE 7.1 Merge two sorted lists
    CLOSED: [2017-06-21 Wed 12:53]

    Write a program that takes two lists, assumed to be sorted, and returns
    their merge. The only field your program can change in a node is its =next=
    field.

    /Hint/: Two sorted arrays can be merged using two indices. For lists, take
    care when one iterator reaches the end.
    
**** Solution

     We describe a solution that completes the task in linear time and constant
     space.

     Call input lists =A= and =B=.

     We decide on the head of the return list with respect to comparison. We
     save a reference =H= to this head for final return; in the meantime, we
     create an additional "work-in-progress" reference =l= that we will use to
     iteratively wire up the return value.

     While neither =A= nor =B= have reached their ends, we compare the head
     values of each; whichever is less than or equal to the other, becomes the
     new target for =l.next=. We then increment both the assignee and =l= to
     their next links.

     Once one of =A= or =B= have reached their end, we treat the other as the
     "remainder" list. Since the two input lists are given to be sorted, we have
     the invariant that every element in the remainder is greater than or equal
     to the current =l=. As such, we assign =l.next = remainder=.

     For this solution's purpose, we define a lightweight linked-list API as
     follows:

     #+BEGIN_SRC python :results silent :session
       class LL():
           def __init__(self, v):
               self.v = v
               self.next = None
           def append(self, l):
               self.next = l
           def __eq__(self,l):
               me = self
               while me is not None and l is not None:
                   if me.v != l.v:
                       return False
                   me = me.next
                   l = l.next
               return me is None and l is None 
     #+END_SRC

     Our solution is as follows:
     #+BEGIN_SRC python :results silent :session
       def merge(A,B):
           if A is None:
               return B
           if B is None:
               return A
           if A.v < B.v:
               head = A
               A = A.next
           else:
               head = B
               B = B.next
           l = head # wip tracker
           cursors = { "A": A, "B": B }
           while cursors["A"] is not None and cursors["B"] is not None:
               k_next = "A" if cursors["A"].v < cursors["B"].v else "B"
               l.next = cursors[k_next]
               l = l.next
               cursors[k_next] = cursors[k_next].next
           l.next = cursors["A"] if cursors["A"] is not None else cursors["B"]
           return head
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           merge(None,None) == None,
           merge(None, LL(1).append(LL(2))) == LL(1).append(LL(2)),
           merge(LL(1).append(LL(3)), None) == LL(1).append(LL(3)),
           merge(
               LL(1).append(LL(3).append(LL(5))),
               LL(2).append(LL(4).append(LL(6))),
           ) == LL(1).append(LL(2).append(LL(3).append(LL(4).append(LL(5).append(LL(6)))))),
       ])
     #+END_SRC

     #+RESULTS:
     : True
     
** 8 Stacks and Queues
   
*** DONE 8.1 Implement a stack with =max= API
    CLOSED: [2017-06-21 Wed 01:06]

    Design a stack that includes a max operation, in addition to push and
    pop. The max method should return the maximum value stored in the stack.
    
**** Solution

     We can use an augmentation of a "vanilla" stack for this purpose. Each
     element of this augmented stack -- call it a "max stack" -- will maintain a
     record of the maximum value at or below its current level. This will allow
     us to preserve the following invariant for given max-stack =S=:

     #+BEGIN_VERBATIM
     S.head.max = max(S)
     #+END_VERBATIM

     We can implement the max-stack as follows:

     #+BEGIN_SRC python :results silent :session
       class MaxStack():
           def __init__(self, *args):
               self.record = []
               for v in args:
                   self.push(v)
           def push(self, v):
               if not self.record:
                   self.record.append((v,v))
               else:
                   self.record.append((v,max(v,self.record[-1][1])))
               return self
           def pop(self):
               if not self.record:
                   return None
               out = self.record[-1][0]
               self.record = self.record[0:-1]
               return out
           # drop silently pops 
           def drop(self):
               self.pop()
               return self
           def max(self):
               if not self.record:
                   return None
               return self.record[-1][1]
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           MaxStack(1,4,3,2,5).max() == 5,
           MaxStack(1,4,3,2,5).drop().max() == 4,
           MaxStack(2,3,4,1).drop().drop().max() == 3,
       ])
     #+END_SRC

     #+RESULTS:
     : True

     This implementation is:

     - O(1) for push;
     - O(1) for pop;
     - O(1) for max lookup.


     Space complexity is O(2n) = O(n), where n is the stack size.
     
** 9 Binary Trees

*** TODO 9.1 Test if a binary tree is height-balanced
    
** 10 Heaps
   
** 11 Searching
   
** 12 Hash Tables
   
** 13 Sorting
   
** 14 Binary Search Trees
   
** 15 Recursion
   
** 16 Dynamic Programming
   
** 17 Greedy Algorithms and Invariants
   
** 18 Graphs
   
** 19 Parallel Computing
   
* Domain Specific Problems
  
** 20 Design Problems
   
** 21 Language Questions
   
** 22 Object-Oriented Design
   
** 23 Common Tools
   
* Honors Class
  
* (Un)license
  
  #+BEGIN_SRC text :eval never
    This is free and unencumbered software released into the public domain.

    Anyone is free to copy, modify, publish, use, compile, sell, or
    distribute this software, either in source code form or as a compiled
    binary, for any purpose, commercial or non-commercial, and by any
    means.

    In jurisdictions that recognize copyright laws, the author or authors
    of this software dedicate any and all copyright interest in the
    software to the public domain. We make this dedication for the benefit
    of the public at large and to the detriment of our heirs and
    successors. We intend this dedication to be an overt act of
    relinquishment in perpetuity of all present and future rights to this
    software under copyright law.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
    OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

    For more information, please refer to <http://unlicense.org>
  #+END_SRC
