#+TITLE: Elements of Programming Interviews: Solutions
#+AUTHOR: Jonathan Jin
#+STARTUP: logdone showall
#+TODO: TODO(t) | WRITTEN(w) PSEUDOCODE(c) DONE(d)

* Table of Contents                                                  :TOC:TOC_3:
- [[#data-structures-and-algorithms][Data Structures and Algorithms]]
  - [[#4-primitive-types][4 Primitive Types]]
    - [[#41-computing-the-parity-of-a-word][4.1 Computing the parity of a word]]
  - [[#5-arrays][5 Arrays]]
    - [[#51-the-dutch-national-flag-problem][5.1 The Dutch national flag problem]]
    - [[#56-buy-and-sell-a-stock-once][5.6 Buy and sell a stock once]]
  - [[#6-strings][6 Strings]]
    - [[#62-base-conversion][6.2 Base conversion]]
    - [[#64-replace-and-remove][6.4 Replace and remove]]
  - [[#7-linked-lists][7 Linked Lists]]
    - [[#71-merge-two-sorted-lists][7.1 Merge two sorted lists]]
  - [[#8-stacks-and-queues][8 Stacks and Queues]]
    - [[#81-implement-a-stack-with-max-api][8.1 Implement a stack with =max= API]]
  - [[#9-binary-trees][9 Binary Trees]]
    - [[#91-test-if-a-binary-tree-is-height-balanced][9.1 Test if a binary tree is height-balanced]]
  - [[#10-heaps][10 Heaps]]
  - [[#11-searching][11 Searching]]
    - [[#111-search-a-sorted-array-for-first-occurrence-of-k][11.1 Search a sorted array for first occurrence of =k=]]
  - [[#12-hash-tables][12 Hash Tables]]
    - [[#122-is-an-anonymous-letter-constructible][12.2 Is an anonymous letter constructible?]]
  - [[#13-sorting][13 Sorting]]
    - [[#131-compute-the-intersection-of-two-sorted-arrays][13.1 Compute the intersection of two sorted arrays]]
  - [[#14-binary-search-trees][14 Binary Search Trees]]
    - [[#written-141-test-if-a-binary-tree-satisfies-the-bst-property][WRITTEN 14.1 Test if a binary tree satisfies the BST property]]
  - [[#15-recursion][15 Recursion]]
    - [[#151-tower-of-hanoi][15.1 Tower of Hanoi]]
  - [[#16-dynamic-programming][16 Dynamic Programming]]
    - [[#written-161-count-the-number-of-score-combinations][WRITTEN 16.1 Count the number of score combinations]]
    - [[#163-count-the-number-of-ways-to-traverse-a-2d-array][16.3 Count the number of ways to traverse a 2D array]]
    - [[#164-compute-the-binomial-coefficient-without-overflow][16.4 Compute the binomial coefficient without overflow]]
    - [[#165-search-for-a-sequence-in-a-2d-array][16.5 Search for a sequence in a 2D array]]
  - [[#17-greedy-algorithms-and-invariants][17 Greedy Algorithms and Invariants]]
  - [[#18-graphs][18 Graphs]]
    - [[#181-search-a-maze][18.1 Search a maze]]
  - [[#19-parallel-computing][19 Parallel Computing]]
- [[#domain-specific-problems][Domain Specific Problems]]
  - [[#20-design-problems][20 Design Problems]]
  - [[#21-language-questions][21 Language Questions]]
  - [[#22-object-oriented-design][22 Object-Oriented Design]]
  - [[#23-common-tools][23 Common Tools]]
- [[#honors-class][Honors Class]]
- [[#unlicense][(Un)license]]

* Data Structures and Algorithms

** 4 Primitive Types

*** DONE 4.1 Computing the parity of a word
    CLOSED: [2017-06-21 Wed 00:44]
    
    The parity of a binary word is 1 if the number of 1s in the word is odd;
    otherwise, it is 0. For example, the parity of 1011 is 1, and the parity of
    10001000 is 0. Parity checks are used to detect single bit errors in data
    storage and communication. It is fairly straightforward to write code that
    computes the parity of a single 64-bit word
    
**** Solution

     We assume that the word is provided as a 64-bit unsigned integer.

     A naive implementation would be to iterate through every bit of the word,
     XOR-ing a counter for every 1-bit.

     #+BEGIN_SRC python :results silent :session
       def parity(word):
           p = 0
           for shift in range(0,64):
               p ^= (word>>shift)&1
           return p
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([parity(int(w,2))==p for w,p in [
           ("1011", 1),
           ("0000", 0),
       ]])
     #+END_SRC

     #+RESULTS:
     : True

     This implementation is O(n), where n is the length of the input word.

     We can, however, optimize this function further by precomputing the
     parities of words and storing the parities in a lookup table. For
     illustration's purpose, we'll define a lookup table that stores the
     parities of all words of length 2:

     #+BEGIN_SRC python :results none :session
       PARITIES_2 = {
           int(w,2): p for w,p in [
               ("00", 0),
               ("01", 1),
               ("10", 1),
               ("11", 0),
           ]
       }
     #+END_SRC

     Resulting in the following implementation:

     #+BEGIN_SRC python :results none :session
       def memoized_parity(word):
           p = 0
           memo_word_length = 2
           for s in range(0,64/memo_word_length):
               mask = 2^memo_word_length - 1
               shift = s * memo_word_length
               p ^= PARITIES_2[(word >> shift) & mask]
           return p
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([memoized_parity(int(w,2))==p for w,p in [
           ("1011", 1),
           ("0000", 0),
       ]])
     #+END_SRC

     #+RESULTS:
     : True

     This revised implementation is O(n/w) = O(n), where w is the word length of
     the lookup key.
     
** 5 Arrays
   
*** TODO 5.1 The Dutch national flag problem

    Write a program that takes an array A and an index i into A, and rearranges
    the elements such that all elements less than A[i] (the "pivot") appear
    first, followed by eleents equal to the pivot followed by elements greater
    than the pivot.

    /Hint/: Think about the partition step in quicksort.

**** Solution

*** DONE 5.6 Buy and sell a stock once
    CLOSED: [2017-06-22 Thu 12:28]

    This problem is concerned with the problem of optimally buying and selling a
    stock once. As an example, consider the following sequence of stock prices:
    =<310, 315, 275, 295, 260, 270, 290, 230, 255, 250>=. The maximum profit
    that can be made with one buy and one sell is 30 -- buy at 260 and sell
    at 290. Note that 260 is not the lowest price, nor 290 the highest price.

    Write a program that takes an array denoting the daily stock price, and
    returns the maximum profit that could be made by buying and then selling one
    share of that stock.
    
**** Solution

     Note that this problem is a simplification of the knapsack problem. A naive
     solution would reduce this problem to its inspiration, giving us a O(n^2)
     solution.  However, we note that the problem doesn't ask for exactly
     *which* stocks to buy and sell for maximum profit -- only the profit
     amount. This simplification means that we do not need the comprehensive
     bookkeeping that a DP-based solution to the knapsack problem provides us.

     We first note that a lower buying price always results in a higher profit
     with the same selling price.

     We can then implement a O(n) solution that compares the "current profit" --
     defined as difference between the current sell-price under consideration
     and the as-yet-seen lowest buy price, with a rolling maximum of that
     value. Every time we see a value less than the as-yet-seen lowest buy
     price, we update accordingly. Once we reach the end of the list, we return
     the rolling max value.

     #+BEGIN_SRC python :results silent :session
       def max_profit(*args):
           min_so_far = args[0]
           profit = 0
           for p in args:
               profit = max(profit, p - min_so_far)
               if p < min_so_far:
                   min_so_far = p
           return profit
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       max_profit(310,315,275,295,260,270,290,230,255,250) == 30
     #+END_SRC

     #+RESULTS:
     : True

** 6 Strings
   
*** TODO 6.2 Base conversion

    In the decimal number system, the position of a digit is used to signify the
    power of 10 that digit is to be multiplied with. For example, "314" denotes
    the number 3 * 100 + 1 * 10 + 4 * 1. The base b number system generalizes
    the decimal number system: the string "a_{k-1}a_{k-2}...a_{1}a_{1}", where 0 \leq a_i \leq
    b, denotes in base-b the integer a_0 \times b^0 + a_1 \times b^1 + a_2 \times
    b^2 + ... + a_{k-1} \times b^{k-1}.

    Write a program that performs base conversion. The input is a string, an
    integer b_1, and another integer b_2. The string represents an integer in base
    b_1. The output should be the string representing the integer in base
    b_2. Assume 2 \leq b_1, b_2 \leq 16. Use "A" to represent 10, "B" for 11, ..., and
    "F" for 15. (For example, if the string is "615", b_1 is 7 and b_2 is 13, then
    the result should be "1A7", since 6 \times 7^2 + 1 \times 7 + 5 = 1 \times 13^2 + 10 \times 13 + 7).

*** TODO 6.4 Replace and remove

    Consider the following two rules that are to be applied to an array of
    characters.

    - Replace each "a" by two "d"s.
    - Delete each entry containing a "b".


    For example, applying these rules to the array =<a,c,d,b,b,c,a>= results in
    the array =<d,d,c,d,c,d,d>=.

    Write a program which takes as input an array of characters, and removes
    each "b" and replaces each "a" by two "d"s. Specifically, along with the
    array, you are provided an integer-valued size. Size denotes the number of
    entries of the array that the operation is to be applied to. You do not
    have to worry about preserving subsequent entries. For example, if the array
    is =<a,b,a,c,_>= and the size is 4, then you can return =<d,d,d,d,c>=. You
    can assume there is enough space in the array to hold the final result.
    
** 7 Linked Lists

*** DONE 7.1 Merge two sorted lists
    CLOSED: [2017-06-21 Wed 12:53]

    Write a program that takes two lists, assumed to be sorted, and returns
    their merge. The only field your program can change in a node is its =next=
    field.

    /Hint/: Two sorted arrays can be merged using two indices. For lists, take
    care when one iterator reaches the end.
    
**** Solution

     We describe a solution that completes the task in linear time and constant
     space.

     Call input lists =A= and =B=.

     We decide on the head of the return list with respect to comparison. We
     save a reference =H= to this head for final return; in the meantime, we
     create an additional "work-in-progress" reference =l= that we will use to
     iteratively wire up the return value.

     While neither =A= nor =B= have reached their ends, we compare the head
     values of each; whichever is less than or equal to the other, becomes the
     new target for =l.next=. We then increment both the assignee and =l= to
     their next links.

     Once one of =A= or =B= have reached their end, we treat the other as the
     "remainder" list. Since the two input lists are given to be sorted, we have
     the invariant that every element in the remainder is greater than or equal
     to the current =l=. As such, we assign =l.next = remainder=.

     For this solution's purpose, we define a lightweight linked-list API as
     follows:

     #+BEGIN_SRC python :results silent :session
       class LL():
           def __init__(self, v):
               self.v = v
               self.next = None
           def append(self, l):
               self.next = l
           def __eq__(self,l):
               me = self
               while me is not None and l is not None:
                   if me.v != l.v:
                       return False
                   me = me.next
                   l = l.next
               return me is None and l is None 
     #+END_SRC

     Our solution is as follows:

     #+BEGIN_SRC python :results silent :session
       def merge(A,B):
           if A is None:
               return B
           if B is None:
               return A
           if A.v < B.v:
               head = A
               A = A.next
           else:
               head = B
               B = B.next
           l = head # wip tracker
           cursors = { "A": A, "B": B }
           while cursors["A"] is not None and cursors["B"] is not None:
               k_next = "A" if cursors["A"].v < cursors["B"].v else "B"
               l.next = cursors[k_next]
               l = l.next
               cursors[k_next] = cursors[k_next].next
           l.next = cursors["A"] if cursors["A"] is not None else cursors["B"]
           return head
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           # base cases
           merge(None,None) == None,
           merge(None, LL(1).append(LL(2))) == LL(1).append(LL(2)),
           merge(LL(1).append(LL(3)), None) == LL(1).append(LL(3)),

           # "normal" case
           merge(
               LL(1).append(LL(3).append(LL(5))),
               LL(2).append(LL(4).append(LL(6))),
           ) == LL(1).append(LL(2).append(LL(3).append(LL(4).append(LL(5).append(LL(6)))))),

           # remainder case
           merge(
               LL(1).append(LL(5)),
               LL(2).append(LL(6).append(LL(10))),
           ) == LL(1).append(LL(2).append(LL(5).append(LL(6).append(LL(10))))),
       ])
     #+END_SRC

     #+RESULTS:
     : True

** 8 Stacks and Queues
   
*** DONE 8.1 Implement a stack with =max= API
    CLOSED: [2017-06-21 Wed 01:06]

    Design a stack that includes a max operation, in addition to push and
    pop. The max method should return the maximum value stored in the stack.
    
**** Solution

     We can use an augmentation of a "vanilla" stack for this purpose. Each
     element of this augmented stack -- call it a "max stack" -- will maintain a
     record of the maximum value at or below its current level. This will allow
     us to preserve the following invariant for given max-stack =S=:

     #+BEGIN_VERBATIM
     S.head.max = max(S)
     #+END_VERBATIM

     We can implement the max-stack as follows:

     #+BEGIN_SRC python :results silent :session
       class MaxStack():
           def __init__(self, *args):
               self.record = []
               for v in args:
                   self.push(v)
           def push(self, v):
               if not self.record:
                   self.record.append((v,v))
               else:
                   self.record.append((v,max(v,self.record[-1][1])))
               return self
           def pop(self):
               if not self.record:
                   return None
               out = self.record[-1][0]
               self.record = self.record[0:-1]
               return out
           # drop silently pops 
           def drop(self):
               self.pop()
               return self
           def max(self):
               if not self.record:
                   return None
               return self.record[-1][1]
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           MaxStack(1,4,3,2,5).max() == 5,
           MaxStack(1,4,3,2,5).drop().max() == 4,
           MaxStack(2,3,4,1).drop().drop().max() == 3,
       ])
     #+END_SRC

     #+RESULTS:
     : True

     This implementation is:

     - O(1) for push;
     - O(1) for pop;
     - O(1) for max lookup.


     Space complexity is O(2n) = O(n), where n is the stack size.
     
** 9 Binary Trees

*** TODO 9.1 Test if a binary tree is height-balanced
    
** 10 Heaps
   
** 11 Searching

*** TODO 11.1 Search a sorted array for first occurrence of =k=

    Binary search commonly asks for the index of /any/ element of a sorted array
    that is equal to a specified element. The following problem has a slight
    twist on this.

    Write a method that takes a sorted array and a key and returns the index of
    the /first/ occurrence of the key in the array.
     
** 12 Hash Tables

*** DONE 12.2 Is an anonymous letter constructible?
    CLOSED: [2017-06-23 Fri 12:41]

    Write a program which takes text for an anonymous letter and text for a
    magazine and determines if it is possible to write the anonymous letter
    using the magazine. The letter can be written using the magazine if for each
    character in the letter, the number of times it appears in the anonymous
    letter is no more than the number of times it appears in the magazine.

**** Solution

     We implement a solution that reduces the letter and the magazine into
     dictionaries. We then check that the magazine dictionary contains all of
     the letter dictionary's keys and, for each of those keys, that it maps to a
     count greater than or equal to that contained in the letter dictionary.

     This solution is in time O(n) with respect to the cumulative length of the
     letter and magazine. Space is, similarly, O(n).

     For the sake of simplicity, we assume that inputs do not contain
     spaces. Accounting for spaces is trivial and would simply involve splitting
     each input on whitespace characters and iterating across sub-lists.

     #+BEGIN_SRC python :results output :session
       def is_possible(l, m):
           def to_dict(s):
               out = {}
               for c in s:
                   if c not in out:
                       out[c] = 0
                   out[c] += 1
               return out

           dl = to_dict(l)
           dm = to_dict(m)

           for k,v in dl.iteritems():
               if k not in dm or dm[k] < v:
                   return False

           return True
     #+END_SRC
     
** 13 Sorting

*** DONE 13.1 Compute the intersection of two sorted arrays
    CLOSED: [2017-06-23 Fri 15:24]

    Write a program which takes as input two sorted arrays, and returns a new
    array containing elements that are present in both of the input arrays. The
    input arrays may have duplicate entries, but the returned array should be
    free of duplicates. For example, if the input is =<2,3,3,5,5,6,7,7,8,12>=
    and =<5,5,6,8,8,9,10,10>=, your output should be =<5,6,8>=.

**** Solution

     #+BEGIN_SRC python :results output :session
       def intersection(A,B):
           if not A or not B:
               return []
           out = []
           lower,upper = A, B
           while lower and upper:
               lower = lower if lower[0] < upper[0] else upper
               upper = upper if lower[0] < upper[0] else lower
               while lower and lower[0] != upper[0]:
                   lower = lower[1:]
               if not lower or not upper:
                   break
               item = lower[0]
               out.append(item)
               while lower and lower[0] == item:
                   lower = lower[1:]
               while upper and upper[0] == item:
                   upper = upper[1:]
           return out
     #+END_SRC

     #+RESULTS:

     #+BEGIN_SRC python :results value :session
       all([
           intersection([],[]) == [],
           intersection([],[1,2,3]) == [],
           intersection([1,2,3],[]) == [],
           intersection(
               [1,2,3,4,5],
               [4,4,5,6,7],
           ) == [4,5,6,7],
           intersection(
               [1,2,3],
               [4,5,6],
           ) == [],
       ])  
     #+END_SRC

     #+RESULTS:
     : True

     This implementation is linear on its inputs.

** 14 Binary Search Trees

*** WRITTEN 14.1 Test if a binary tree satisfies the BST property
    CLOSED: [2017-06-23 Fri 12:20]

    Write a program that takes as input a binary tree and checks if the tree
    satisfies the BST property.

**** Solution

     Iterate through each subtree, keeping track of a local maximum and
     minimum. In addition to asserting that the two leaves relate to the node as
     necessary, similarly assert that the two leaves fall within the maximum and
     minimum. When recursing into leaves, update either the maximum or the
     minimum with the current node value depending on which leave is being
     recursed into.

** 15 Recursion

*** TODO 15.1 Tower of Hanoi
     
** 16 Dynamic Programming

*** WRITTEN 16.1 Count the number of score combinations
    CLOSED: [2017-06-23 Fri 15:03]

    In an American football game, a play can lead to 2 points (safety), 3 points
    (field goal), or 7 points (touchdown, assuming the extra point). Many
    different combinations of 2, 3, and 7 point plays can make up a final
    score. For example, four combinations of plays yield a score of 12:

    - 6 safeties;
    - 3 safeties, 2 field goals;
    - 1 safety, 1 field goal, and 1 touchdown;
    - 4 field goals.


    Write a program that takes a final score and scores for individual plays,
    and returns the number of combinations of plays that result in the final
    score.

**** Solution

     We can memoize the number of combinations that lead to certain scores,
     iterating through the memo to arrive at the desired final score and, as a
     result, the final combination count.

     Say we have possible play scores 2 and 3, and we'd like the number of
     possible plays that could lead to a score of 9. We can represent our memo
     as a two-dimensional array, where one axis is the score and the other
     represents the set of plays that can comprise the score, the first index
     representing, in this case, the set ={2}= and the second, the set ={2,3}=.

     We note that, for a given score =S= and a given set of plays =P = {P', p}=,
     number of combinations leading to score =S= =N(S, P)= equals (informally):

     =N(S-p, P') + N(S-2p, P') + ... + N(0, P')=

     We say that =N(x, y) = 0= for =x<0= and any =y=.

     |         | *0* | *1* | *2* | *3* | *4* | *5* | *6* | *7* | *8* | *9* |
     | ={2}=   |   1 |   0 |   1 |   0 |   1 |   0 |   1 |   0 |   1 |   0 |
     | ={2,3}= |   1 |   0 |   1 |   1 |   1 |   1 |   2 |   1 |   2 |   2 |

     A solution that uses this memoization strategy will be =O(S \times |P|)=, where
     =S= is the score and =P= is the set of play scores. Likewise for space.

*** DONE 16.3 Count the number of ways to traverse a 2D array
    CLOSED: [2017-06-23 Fri 19:18]

**** Solution

     Our memoization strategy is as follows. We use a matrix T of the same
     shape as the input matrix M to track the number of ways to traverse to
     that point in the input. Matrix T is populated according to function
     T(i,j), which we define as follows:

     - T(i,j) = T(i-1,j) + T(i, j-1)
     - T(i, j) = 0 \forall j \in \real, i < 0
     - T(i, j) = 0 \forall j < 0, i \in \real


     Our solution then becomes as follows:

     #+BEGIN_SRC python :results silent :session
       def num_traversals(M):
           t = [[0 for _ in M[0]] for _ in M]
           def T(t, i,j):
               if i == -1 or j == -1:
                   return 0
               if i == 0 and j == 0:
                   return 1
               return t[i-1][j] + t[i][j-1]
           for i in range(0, len(M)):
               for j in range(0, len(M[i])):
                   t[i][j] = T(t, i, j)
           return t[len(M)-1][len(M[0])-1]
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           num_traversals([[0,0,0,0,0] for _ in xrange(5)]) == 70,
       ])
     #+END_SRC

     This implementation is linear for both time and space with respect to the
     number of elements in the input matrix.

*** DONE 16.4 Compute the binomial coefficient without overflow
    CLOSED: [2017-06-24 Sat 21:10]

**** Solution

     For illustration's purpose, we outline a C matrix, where C[n][k] = C(n+1,k+1)
     \forall n,k \in \real:

     | 1 | 2 | 3 | 4 |
     | 0 | 1 | 3 | 6 |
     | 0 | 0 | 1 | 4 |
     | 0 | 0 | 0 | 1 |

     We note that this gives us the following recursive definition of the
     binominal coefficient: C(n, k) = C(n-1, k-1) + C(n-1, k). A naive
     implementation would directly translate this recursive definition into a
     recursive implementation, resulting in re-computation of the same values
     for exponential time complexity w.r.t nk. Instead, we memoize intermediate
     results in a manner identical to the example matrix above:

     #+BEGIN_SRC python :results output :session
       def bico(n,k):
           def C(_C, n, k):
               if n == k:
                   return 1
               elif k == 0:
                   return n + 1
               elif k > n:
                   return 0
               else:
                   return _C[k-1][n-1] + _C[k][n-1]
           _C = [[0 for _ in xrange(n)] for _ in xrange(k)]
           for _k in range(0, k):
               for _n in range(0, n):
                   _C[_k][_n] = C(_C, _n, _k)
           return _C[k-1][n-1]
     #+END_SRC

     #+RESULTS:

     #+BEGIN_SRC python :results output :session
       all([
           bico(29, 3) == 3654,
           bico(3, 2) == 3,
       ])
     #+END_SRC

     This solution is O(nk) for both time and space.

*** DONE 16.5 Search for a sequence in a 2D array
    CLOSED: [2017-06-24 Sat 22:48]

    Write a program that takes as arguments a 2D array and a 1D array, and
    checks whether the 1D array appears in the 2D array.

**** Solution

     We can use iteration through each element of the 2D array as the backbone
     of our solution's logic; during iteration, if we encounter an element
     that's equal to the first element of the sequence, we break into tracing
     logic. This tracing logic considers all of the element's "neighbors" to see
     if they equal the next value in the sequence. We "trace" the sequence in
     this way; if we reach the end of the sequence in this way, we return true
     and are done. If, however, tracing leads to only a partial match, we mark
     the latest element in the trace as "invalid" and propagate that mark
     backwards through the trace. This is to prevent re-tracing of paths that
     are already known to be "lost causes" -- an implementation that would lead
     to time complexity of O(nml), where n and m are the matrix's dimensions and
     l is the length of the sequence.

     #+BEGIN_SRC python :results silent :session
       def contains_sequence(M, S):
           # eligibility matrix
           m_e = [[True for _ in xrange(len(M[0]))] for _ in xrange(len(M))]
           def neighbor_coords(i, j):
               if i < len(M)-1:
                   yield (i+1, j)
               if i > 0:
                   yield (i-1, j)
               if j < len(M[0])-1:
                   yield (i, j+1)
               if j > 0:
                   yield (i, j-1)
           def trace(i, j, seq):
               if not seq:
                   return True
               if not m_e[i][j]:
                   return False
               if M[i][j] != seq[0] or not any([
                       trace(nc[0], nc[1], seq[1:]) for nc in neighbor_coords(i, j)
               ]):
                   m_e[i][j] = False
                   return False
               else:
                   return True
           for i in range(0, len(M)):
               for j in range(0, len(M[0])):
                   if trace(i, j, S):
                       return True
           return False
     #+END_SRC

     #+BEGIN_SRC python :results value :session
       all([
           contains_sequence(M, S) == r for M,S,r in [
               (
                   [[1,2,5],
                    [3,4,3],
                    [5,6,7]],
                   [3,4,7],
                   False,
               ),
               (
                   [[1,2,5],
                    [3,4,3],
                    [5,6,7]],
                   [3,4,6,7],
                   True,
               ),
               (
                   [[1,2,3],
                    [3,4,5],
                    [5,6,7]],
                   [1,3,4,6],
                   True,
               ),
               (
                   [[1,2,3],
                    [3,4,5],
                    [5,6,7]],
                   [1,2,3,4],
                   False,
               ),
           ]
       ])
     #+END_SRC

     #+RESULTS:
     : True

     
** 17 Greedy Algorithms and Invariants
   
** 18 Graphs

*** TODO 18.1 Search a maze

    Given a 2D array of black and white entries representing a maxe with
    designated entrance and exit points, find a path from the entrance to the
    exit, if one exists.

    /Hint/: Model the maze as a graph.

**** Solution

     We treat the 2D array as a graph and implement DFS.
     
** 19 Parallel Computing
   
* Domain Specific Problems
  
** 20 Design Problems
   
** 21 Language Questions
   
** 22 Object-Oriented Design
   
** 23 Common Tools
   
* Honors Class
  
* (Un)license
  
  #+BEGIN_SRC text :eval never
    This is free and unencumbered software released into the public domain.

    Anyone is free to copy, modify, publish, use, compile, sell, or
    distribute this software, either in source code form or as a compiled
    binary, for any purpose, commercial or non-commercial, and by any
    means.

    In jurisdictions that recognize copyright laws, the author or authors
    of this software dedicate any and all copyright interest in the
    software to the public domain. We make this dedication for the benefit
    of the public at large and to the detriment of our heirs and
    successors. We intend this dedication to be an overt act of
    relinquishment in perpetuity of all present and future rights to this
    software under copyright law.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
    OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

    For more information, please refer to <http://unlicense.org>
  #+END_SRC
